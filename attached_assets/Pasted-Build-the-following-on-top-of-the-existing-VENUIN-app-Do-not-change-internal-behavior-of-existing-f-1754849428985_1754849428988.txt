Build the following on top of the existing VENUIN app. Do not change internal behavior of existing features (venues, spaces, bookings, proposals, contracts, payments, CRM, AI). Add multi-tenant billing where plans are created only by Superadmin (no predefined tiers).

0) Context (stack already in project)
Frontend: React 18 + TS, Vite, Wouter, TanStack Query v5, shadcn/ui (Radix), RHF + Zod, Tailwind, Lucide
Backend: Node + Express (TS), Drizzle + Postgres (Neon), connect-pg-simple sessions
Extras: Google Gemini, Gmail API

1) Data model (Drizzle migrations)
Extend/create:

featurePackages:

id (uuid), name, slug (unique), status enum(draft|active|archived),

billingModes JSON (e.g. { monthly: { amount: 6900, currency: "usd" }, yearly?: {...} }),

stripeProductId (nullable), stripePriceIds JSON { monthly?: string, yearly?: string },

trialDays int (nullable),

limits JSON (e.g. { venues:1, spacesPerVenue:5, staff:3, monthlyBookings:50 }),

flags JSON (booleans/strings), sortOrder int, timestamps.

tenants: add planSlug (nullable), stripeCustomerId, stripeSubscriptionId, status enum(active|past_due|canceled|suspended), trialEnd (timestamp, nullable).

auditLogs: id, actorUserId, tenantId (nullable), action, entity, meta JSON, ip, userAgent, timestamps.

2) Superadmin Plan Builder (no predefined plans)
Routes under /super-admin/plans:

CRUD plans with validations (unique slug, positive prices).

Toggle status: draft (not public), active (public), archived (hidden; cannot choose at signup; cannot delete if in use).

Stripe Sync button:

Create/Update Product + Price(s) (monthly/yearly).

Store stripeProductId and stripePriceIds. Idempotent by slug.

Clone plan action.

Safe delete rule: if tenants exist on plan → block; suggest archive.

3) Public Plans API (for landing & signup)
GET /api/public/plans → only status=active. Return safe fields: name, slug, billingModes (display prices), trialDays, and summarized highlights derived from flags/limits.

If no active plans, return empty array.

4) Landing page & Signup
/ (marketing): show simple pricing cards from /api/public/plans. Per requirement: do not list detailed feature bullets; just “All VENUIN features included; plan limits apply.”

/signup: fields = company name, admin full name, email, password, plan (from /api/public/plans), interval (monthly|yearly).

On submit → create Stripe Checkout Session using selected plan’s Price ID.

Success URL → /signup/success?session_id=... (frontend calls backend to finalize).

If no active plans → show friendly message “Plans coming soon. Contact sales at {CONFIG_SALES_EMAIL}.”

5) Stripe integration
Webhook endpoint with signature verification and idempotency:

checkout.session.completed → create tenant + admin user; set planSlug, stripeCustomerId, stripeSubscriptionId, status="active", and trialEnd if trialDays present; write audit log.

invoice.payment_succeeded → status="active"; log.

invoice.payment_failed → status="past_due"; log.

customer.subscription.updated|deleted → update planSlug if price changed; set past_due|canceled; log.

Tenant Billing page: “Manage Subscription” → open Stripe Customer Portal.

6) Enforcement (limits & flags)
Backend middleware (global on business routes) that:

Resolves tenantId from session.

Loads tenant → loads featurePackages by planSlug.

Enforces limits server-side (venues, spaces, staff, monthlyBookings). On violation, respond 402-style JSON:
{ code:"LIMIT_REACHED", limit:"venues", plan: planSlug, message:"Your plan allows 1 venue. Upgrade to add more." }

Provides flags to the request context.
Frontend:

Hide gated buttons by flag.

When API returns LIMIT_REACHED, open “Upgrade” modal using /api/public/plans.

Tenant statuses:

active: full access

past_due: read-only except Billing

canceled|suspended: Billing-only

7) Onboarding (first login)
After provisioning, redirect to /t/:tenantSlug/app/onboarding:

Confirm venue details

Add spaces

Invite team members (email invites)

8) Security, isolation, ops
Global tenant guard on all business endpoints (venues/spaces/bookings/customers/proposals/contracts/payments/etc.) to prevent cross-tenant access even by ID.

Basic rate limiting: auth/signup/payments/AI.

/healthz checks app, DB, session store.

All plan & billing actions write auditLogs.

9) Seeds, env, docs, tests
Seeds: create one superadmin user only. Do not create any plans (unless SEED_SAMPLE_PLANS=true in dev).

.env.example with comments: Neon, STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, PUBLIC_BASE_URL, COOKIE_DOMAIN, SESSION_SECRET, GMAIL/GEMINI keys, CSP allowlist.

OpenAPI 3.1: include GET /api/public/plans, plan CRUD under /api/super-admin/packages/*, signup, Stripe webhook, usage endpoint, and tenant status semantics. Export openapi.yaml.

Playwright e2e:

Zero active plans ⇒ /signup shows disabled message

Create plan (superadmin) ⇒ set active ⇒ plan appears on / and /signup

Signup with plan ⇒ Stripe test checkout ⇒ webhook provisions tenant ⇒ landing in /t/:slug/app

Create 2nd venue on plan limiting to 1 ⇒ API returns LIMIT_REACHED ⇒ UI shows upgrade

Portal downgrade ⇒ webhook updates plan ⇒ limits enforced

Simulate invoice.payment_failed ⇒ past_due UI/read-only; recover after success

Postman collection + envs (dev/stage/prod).

10) Success criteria (must pass)
I can create/edit/activate plans in Superadmin and sync them to Stripe.

/ and /signup reflect only active plans from the API.

Successful checkout provisions tenant/admin tied to chosen plan.

Limits/flags are enforced on server; UI handles gracefully.

Stripe Portal changes + failed invoices update tenant status/plan via webhook.

OpenAPI, seeds, Playwright, Postman, .env.example all generated and usable.

Cross-tenant access is impossible.